package org.opentestsystem.rdw.admin.service.impl;

import com.google.common.base.Joiner;
import com.google.common.collect.ImmutableList;
import org.apache.commons.csv.CSVRecord;
import org.opentestsystem.rdw.admin.common.model.Organization;
import org.opentestsystem.rdw.admin.common.security.PermissionScope;
import org.opentestsystem.rdw.admin.model.CsvSubject;
import org.opentestsystem.rdw.admin.model.CsvValidationFailure;
import org.opentestsystem.rdw.admin.repository.SchoolRepository;
import org.opentestsystem.rdw.admin.service.CsvValidationService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

import static org.apache.commons.lang.StringUtils.isBlank;
import static org.apache.commons.lang.StringUtils.isNotBlank;

/**
 * Default implementation of a CsvValidationService
 */
@Service
public class DefaultCsvValidationService implements CsvValidationService {

    public final static String HeaderGroup = "group_name";
    public final static String HeaderSchool = "school_natural_id";
    public final static String HeaderYear = "school_year";
    public final static String HeaderSubject = "subject_code";
    public final static String HeaderSSID = "student_ssid";
    public final static String HeaderUser = "group_user_login";

    public final static List<String> RequiredHeaders = ImmutableList.of(
            HeaderGroup,
            HeaderSchool,
            HeaderYear,
            HeaderSubject,
            HeaderSSID,
            HeaderUser
    );

    private static final String ValidationFormat = "Row: %1$d Failure: %2$s\n";
    private static final String MoreFailuresFormat = "With %1$d additional validation failures\n";
    private static final int MaxFailureMessages = 100;
    static final int MaxStudentsPerGroup = 200;

    private final SchoolRepository schoolRepository;

    @Autowired
    public DefaultCsvValidationService(final SchoolRepository schoolRepository) {
        this.schoolRepository = schoolRepository;
    }

    @Override
    public List<CsvValidationFailure> validateHeaders(final List<String> csvHeaders) {
        final List<CsvValidationFailure> failures = new ArrayList<>();

        for (int i = 0; i < RequiredHeaders.size(); i++) {
            if (!RequiredHeaders.get(i).equalsIgnoreCase(csvHeaders.get(i))) {
                failures.add(CsvValidationFailure.builder()
                        .row(0)
                        .message("Invalid headers. Headers must be in order: [" +
                                Joiner.on(",").join(RequiredHeaders) +
                                "]")
                        .build());
                break;
            }
        }
        if ( csvHeaders.size() > RequiredHeaders.size() ) {
            failures.add(CsvValidationFailure.builder()
                    .row(0)
                    .message("Invalid headers. Additional headers exist after required headers: [" +
                            Joiner.on(",").join(RequiredHeaders) +
                            "]")
                    .build());
        }
        return failures;
    }

    @Override
    public List<CsvValidationFailure> validateRecords(final Iterator<CSVRecord> recordIterator,
                                                      final PermissionScope permissionScope) {
        final List<CsvValidationFailure> validationFailures = new ArrayList<>();

        final Set<String> availableSchools = schoolRepository.findAll(permissionScope).stream()
                .map(Organization::getNaturalId)
                .collect(Collectors.toSet());

        final Set<String> completedSchools = new HashSet<>();
        final Set<String> completedSchoolGroupYears = new HashSet<>();

        String currentSchool = null;
        String currentGroup = null;
        String currentSchoolGroupYear = null;
        CsvSubject currentSchoolGroupYearSubject = null;
        int studentCount = 0;
        long recordNumber = 0;

        while (recordIterator.hasNext()) {
            final CSVRecord record = recordIterator.next();
            final String school = record.get(HeaderSchool);
            final String group = record.get(HeaderGroup);
            final Integer schoolYear = getAsInt(record, HeaderYear);
            final CsvSubject subject = CsvSubject.valueOfCaseInsensitive(record.get(HeaderSubject));
            recordNumber = record.getRecordNumber();

            validateKeyValues(validationFailures, school, group, schoolYear, recordNumber);
            if (!validationFailures.isEmpty()) continue;

            //Validate the School
            if (currentSchool == null || !currentSchool.equals(school)) {
                if (currentSchool != null) completedSchools.add(currentSchool);
                completedSchoolGroupYears.clear();
                currentSchoolGroupYear = null;
                currentSchool = school;

                validateSchool(validationFailures, availableSchools, completedSchools, school, recordNumber);
            }

            //Validate the School, Group, and Year
            final String schoolGroupYear = school + group + String.valueOf(schoolYear);
            if (currentSchoolGroupYear == null || !currentSchoolGroupYear.equalsIgnoreCase(schoolGroupYear)) {
                if (currentSchoolGroupYear != null) completedSchoolGroupYears.add(currentSchoolGroupYear);
                currentSchoolGroupYearSubject = null;
                currentSchoolGroupYear = schoolGroupYear;

                validateStudentCount(validationFailures, currentSchool, currentGroup, studentCount, recordNumber - 1);
                studentCount = 0;
                currentGroup = group;

                validateSchoolGroupYear(validationFailures, completedSchoolGroupYears, schoolGroupYear, recordNumber);
            }

            //Validate the Subject
            if (currentSchoolGroupYearSubject == null) {
                currentSchoolGroupYearSubject = subject;
            } else if (subject != null && !subject.equals(currentSchoolGroupYearSubject)) {
                validationFailures.add(CsvValidationFailure.builder()
                        .row(recordNumber)
                        .message("Record is attempting to re-define group subject from [" + currentSchoolGroupYearSubject.name() + "] to [" + subject.name() + "]")
                        .build());
                currentSchoolGroupYearSubject = subject;
            }

            //Count students
            if (isNotBlank(record.get(HeaderSSID))) {
                studentCount++;
            }
        }
        validateStudentCount(validationFailures, currentSchool, currentGroup, studentCount, recordNumber);

        return validationFailures;
    }

    private void validateStudentCount(final List<CsvValidationFailure> validationFailures,
                                      final String school,
                                      final String group,
                                      final int studentCount,
                                      final long recordNumber) {
        if (studentCount < MaxStudentsPerGroup) return;

        validationFailures.add(CsvValidationFailure.builder()
                .row(recordNumber)
                .message("School [" + school + "] Group [" + group + "] contains " + studentCount + " students.  Maximum students allowed per group is " + MaxStudentsPerGroup)
                .build());
    }

    private void validateSchoolGroupYear(final List<CsvValidationFailure> validationFailures,
                                         final Set<String> completedSchoolGroupYears,
                                         final String schoolGroupYear,
                                         final long recordNumber) {
        if (completedSchoolGroupYears.contains(schoolGroupYear)) {
            validationFailures.add(CsvValidationFailure.builder()
                    .row(recordNumber)
                    .message("Record is out-of-order: sort CSV by school, group, year")
                    .build());
        }
    }

    @Override
    public String toMessage(final List<CsvValidationFailure> failures) {
        final StringBuilder messageBuilder = new StringBuilder();
        final List<CsvValidationFailure> subList = failures.size() < MaxFailureMessages ? failures : failures.subList(0, MaxFailureMessages);
        for (final CsvValidationFailure failure : subList) {
            messageBuilder.append(String.format(ValidationFormat, failure.getRow(), failure.getMessage()));
        }
        if (failures.size() > MaxFailureMessages) {
            messageBuilder.append(String.format(MoreFailuresFormat, failures.size() - MaxFailureMessages));
        }
        return messageBuilder.toString();
    }

    private Integer getAsInt(final CSVRecord row, final String header) {
        try {
            return Integer.valueOf(row.get(header));
        } catch (final NumberFormatException e) {
            return null;
        }
    }

    private void validateKeyValues(final List<CsvValidationFailure> validationFailures,
                                                         final String school,
                                                         final String group,
                                                         final Integer schoolYear,
                                                         final long recordNumber) {
        if (isBlank(school)) {
            validationFailures.add(CsvValidationFailure.builder()
                    .row(recordNumber)
                    .message("Record does not contain a school")
                    .build());
        }

        if (isBlank(group)) {
            validationFailures.add(CsvValidationFailure.builder()
                    .row(recordNumber)
                    .message("Record does not contain a group name")
                    .build());
        }

        if (schoolYear == null) {
            validationFailures.add(CsvValidationFailure.builder()
                    .row(recordNumber)
                    .message("Record does not contain a school year")
                    .build());
        }
    }

    private void validateSchool(final List<CsvValidationFailure> validationFailures,
                                                      final Set<String> availableSchools,
                                                      final Set<String> completedSchools,
                                                      final String school,
                                                      final long recordNumber) {
        if (!availableSchools.contains(school)) {
            validationFailures.add(CsvValidationFailure.builder()
                    .row(recordNumber)
                    .message("School [" + school + "] can not be found")
                    .build());
        }
        if (completedSchools.contains(school)) {
            validationFailures.add(CsvValidationFailure.builder()
                    .row(recordNumber)
                    .message("School [" + school + "] is out-of-order: sort CSV by school, group, year")
                    .build());
        }
    }

}
