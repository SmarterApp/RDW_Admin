package org.opentestsystem.rdw.admin.service.impl;

import org.apache.commons.csv.CSVRecord;
import org.opentestsystem.rdw.admin.model.CsvSubject;
import org.opentestsystem.rdw.admin.model.CsvValidationFailure;
import org.opentestsystem.rdw.admin.security.User;
import org.opentestsystem.rdw.admin.service.CsvValidationService;
import org.springframework.stereotype.Service;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

import static com.google.common.collect.Sets.newHashSet;
import static org.apache.commons.lang.StringUtils.isBlank;

/**
 * Default implementation of a CsvValidationService
 */
@Service
public class DefaultCsvValidationService implements CsvValidationService {

    private static final String ValidationFormat = "Row: %1$d Failure: %2$s\n";
    private static final String MoreFailuresFormat = "With %1$d additional validation failures\n";
    private static final int MaxFailureMessages = 100;

    @Override
    public List<CsvValidationFailure> validateHeaders(final Set<String> csvHeaders) {
        final List<CsvValidationFailure> failures = new ArrayList<>();
        final Set<String> headers = csvHeaders.stream().map(String::toLowerCase).collect(Collectors.toSet());
        if (!headers.containsAll(RequiredHeaders)) {
            final Set<String> missing = newHashSet(RequiredHeaders);
            missing.removeAll(headers);
            failures.add(CsvValidationFailure.builder()
                    .row(0)
                    .message("Missing headers " + missing + ", found " + headers)
                    .build());
        }
        return failures;
    }

    @Override
    public List<CsvValidationFailure> validateRecords(final Iterator<CSVRecord> recordIterator,
                                                      final User user) {
        final List<CsvValidationFailure> validationFailures = new ArrayList<>();

        final Set<String> schools = new HashSet<>();
        final Set<String> schoolGroupYears = new HashSet<>();

        String currentSchool = null;
        String currentSchoolGroupYear = null;
        CsvSubject currentSchoolGroupYearSubject = null;

        while (recordIterator.hasNext()) {
            final CSVRecord record = recordIterator.next();
            final String school = record.get(HeaderSchool);
            final String group = record.get(HeaderGroup);
            final Integer schoolYear = getAsInt(record, HeaderYear);
            final CsvSubject subject = CsvSubject.valueOfCaseInsensitive(record.get(HeaderSubject));

            if (isBlank(school) && isBlank(group) && schoolYear == null) {
                //Not a viable record, skip
                continue;
            }
            validationFailures.addAll(validateKeyValues(school, group, schoolYear, record.getRecordNumber()));
            if (!validationFailures.isEmpty()) continue;

            if (currentSchool == null || !currentSchool.equals(school)) {
                schools.add(currentSchool);
                schoolGroupYears.clear();
                if (!validateSchoolPermissions(school, user)) {
                    validationFailures.add(CsvValidationFailure.builder()
                            .row(record.getRecordNumber())
                            .message("School [" + school + "] can not be found")
                            .build());
                }
                if (schools.contains(school)) {
                    validationFailures.add(CsvValidationFailure.builder()
                            .row(record.getRecordNumber())
                            .message("School [" + school + "] is out-of-order: sort CSV by school, group, year")
                            .build());
                }
                currentSchool = school;
            }

            final String schoolGroupYear = school + group + schoolYear.toString();
            if (currentSchoolGroupYear == null) {
                currentSchoolGroupYearSubject = null;
                currentSchoolGroupYear = schoolGroupYear;
            } else if (!currentSchoolGroupYear.equalsIgnoreCase(schoolGroupYear)) {
                if (schoolGroupYears.contains(schoolGroupYear)) {
                    validationFailures.add(CsvValidationFailure.builder()
                            .row(record.getRecordNumber())
                            .message("Record [" + school + ", " + group + ", " + schoolYear + "] is out-of-order: sort CSV by school, group, year")
                            .build());
                }
                currentSchoolGroupYearSubject = null;
                schoolGroupYears.add(currentSchoolGroupYear);
                currentSchoolGroupYear = schoolGroupYear;
            }

            if (currentSchoolGroupYearSubject == null) {
                currentSchoolGroupYearSubject = subject;
            } else if (subject != null && !subject.equals(currentSchoolGroupYearSubject)) {
                validationFailures.add(CsvValidationFailure.builder()
                        .row(record.getRecordNumber())
                        .message("Record is attempting to re-define group subject from [" + currentSchoolGroupYearSubject.name() + "] to [" + subject.name() + "]")
                        .build());
                currentSchoolGroupYearSubject = subject;
            }
        }
        return validationFailures;
    }

    private boolean validateSchoolPermissions(final String school, final User user) {
        return false;
    }

    @Override
    public String toMessage(final List<CsvValidationFailure> failures) {
        final StringBuilder messageBuilder = new StringBuilder();
        int maxMessages = MaxFailureMessages;
        for (final CsvValidationFailure failure : failures) {
            messageBuilder.append(String.format(ValidationFormat, failure.getRow(), failure.getMessage()));
            if (maxMessages-- < 0) {
                messageBuilder.append(String.format(MoreFailuresFormat, failures.size() - MaxFailureMessages));
                break;
            }
        }
        return messageBuilder.toString();
    }

    private Integer getAsInt(final CSVRecord row, final String header) {
        try {
            return Integer.valueOf(row.get(header));
        } catch (final NumberFormatException e) {
            return null;
        }
    }

    private List<CsvValidationFailure> validateKeyValues(final String school,
                                                         final String group,
                                                         final Integer schoolYear,
                                                         final long recordNumber) {
        final List<CsvValidationFailure> validationFailures = new ArrayList<>(3);

        if (isBlank(school)) {
            validationFailures.add(CsvValidationFailure.builder()
                    .row(recordNumber)
                    .message("Record does not contain a school")
                    .build());
        }

        if (isBlank(group)) {
            validationFailures.add(CsvValidationFailure.builder()
                    .row(recordNumber)
                    .message("Record does not contain a group name")
                    .build());
        }

        if (schoolYear == null) {
            validationFailures.add(CsvValidationFailure.builder()
                    .row(recordNumber)
                    .message("Record does not contain a school year")
                    .build());
        }

        return validationFailures;
    }

}
