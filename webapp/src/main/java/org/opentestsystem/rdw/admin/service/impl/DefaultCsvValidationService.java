package org.opentestsystem.rdw.admin.service.impl;

import com.google.common.collect.ImmutableSet;
import org.apache.commons.csv.CSVRecord;
import org.opentestsystem.rdw.admin.common.security.PermissionScope;
import org.opentestsystem.rdw.admin.model.CsvSubject;
import org.opentestsystem.rdw.admin.model.CsvValidationFailure;
import org.opentestsystem.rdw.admin.model.School;
import org.opentestsystem.rdw.admin.repository.SchoolRepository;
import org.opentestsystem.rdw.admin.service.CsvValidationService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

import static com.google.common.collect.Sets.newHashSet;
import static org.apache.commons.lang.StringUtils.isBlank;

/**
 * Default implementation of a CsvValidationService
 */
@Service
public class DefaultCsvValidationService implements CsvValidationService {

    final static String HeaderSchool = "school_natural_id";
    final static String HeaderSubject = "subject_code";
    final static String HeaderGroup = "group_name";
    final static String HeaderUser = "group_user_login";
    final static String HeaderYear = "school_year";
    final static String HeaderSSID = "student_ssid";

    final static Set<String> RequiredHeaders = ImmutableSet.of(
            HeaderSchool,
            HeaderSubject,
            HeaderGroup,
            HeaderUser,
            HeaderYear,
            HeaderSSID
    );

    private static final String ValidationFormat = "Row: %1$d Failure: %2$s\n";
    private static final String MoreFailuresFormat = "With %1$d additional validation failures\n";
    private static final int MaxFailureMessages = 100;

    private final SchoolRepository schoolRepository;

    @Autowired
    public DefaultCsvValidationService(final SchoolRepository schoolRepository) {
        this.schoolRepository = schoolRepository;
    }

    @Override
    public List<CsvValidationFailure> validateHeaders(final Set<String> csvHeaders) {
        final List<CsvValidationFailure> failures = new ArrayList<>();
        final Set<String> headers = csvHeaders.stream().map(String::toLowerCase).collect(Collectors.toSet());
        if (!headers.containsAll(RequiredHeaders)) {
            final Set<String> missing = newHashSet(RequiredHeaders);
            missing.removeAll(headers);
            failures.add(CsvValidationFailure.builder()
                    .row(0)
                    .message("Missing headers " + missing + ", found " + headers)
                    .build());
        }
        return failures;
    }

    @Override
    public List<CsvValidationFailure> validateRecords(final Iterator<CSVRecord> recordIterator,
                                                      final PermissionScope permissionScope) {
        final List<CsvValidationFailure> validationFailures = new ArrayList<>();

        final Set<String> availableSchools = schoolRepository.findAll(permissionScope).stream()
                .map(School::getNaturalId)
                .collect(Collectors.toSet());

        final Set<String> completedSchools = new HashSet<>();
        final Set<String> completedSchoolGroupYears = new HashSet<>();

        String currentSchool = null;
        String currentSchoolGroupYear = null;
        CsvSubject currentSchoolGroupYearSubject = null;

        while (recordIterator.hasNext()) {
            final CSVRecord record = recordIterator.next();
            final String school = record.get(HeaderSchool);
            final String group = record.get(HeaderGroup);
            final Integer schoolYear = getAsInt(record, HeaderYear);
            final CsvSubject subject = CsvSubject.valueOfCaseInsensitive(record.get(HeaderSubject));

            validateKeyValues(validationFailures, school, group, schoolYear, record.getRecordNumber());
            if (!validationFailures.isEmpty()) continue;

            //Validate the School
            if (currentSchool == null || !currentSchool.equals(school)) {
                if (currentSchool != null) completedSchools.add(currentSchool);
                completedSchoolGroupYears.clear();
                currentSchoolGroupYear = null;
                currentSchool = school;

                validateSchool(validationFailures, availableSchools, completedSchools, school, record.getRecordNumber());
            }

            //Validate the School, Group, and Year
            final String schoolGroupYear = school + group + String.valueOf(schoolYear);
            if (currentSchoolGroupYear == null || !currentSchoolGroupYear.equalsIgnoreCase(schoolGroupYear)) {
                if (currentSchoolGroupYear != null) completedSchoolGroupYears.add(currentSchoolGroupYear);
                currentSchoolGroupYearSubject = null;
                currentSchoolGroupYear = schoolGroupYear;

                validateSchoolGroupYear(validationFailures, completedSchoolGroupYears, schoolGroupYear, record.getRecordNumber());
            }

            //Validate the Subject
            if (currentSchoolGroupYearSubject == null) {
                currentSchoolGroupYearSubject = subject;
            } else if (subject != null && !subject.equals(currentSchoolGroupYearSubject)) {
                validationFailures.add(CsvValidationFailure.builder()
                        .row(record.getRecordNumber())
                        .message("Record is attempting to re-define group subject from [" + currentSchoolGroupYearSubject.name() + "] to [" + subject.name() + "]")
                        .build());
                currentSchoolGroupYearSubject = subject;
            }
        }

        return validationFailures;
    }

    private void validateSchoolGroupYear(final List<CsvValidationFailure> validationFailures,
                                         final Set<String> completedSchoolGroupYears,
                                         final String schoolGroupYear,
                                         final long recordNumber) {
        if (completedSchoolGroupYears.contains(schoolGroupYear)) {
            validationFailures.add(CsvValidationFailure.builder()
                    .row(recordNumber)
                    .message("Record is out-of-order: sort CSV by school, group, year")
                    .build());
        }
    }

    @Override
    public String toMessage(final List<CsvValidationFailure> failures) {
        final StringBuilder messageBuilder = new StringBuilder();
        final List<CsvValidationFailure> subList = failures.size() < MaxFailureMessages ? failures : failures.subList(0, MaxFailureMessages);
        for (final CsvValidationFailure failure : subList) {
            messageBuilder.append(String.format(ValidationFormat, failure.getRow(), failure.getMessage()));
        }
        if (failures.size() > MaxFailureMessages) {
            messageBuilder.append(String.format(MoreFailuresFormat, failures.size() - MaxFailureMessages));
        }
        return messageBuilder.toString();
    }

    private Integer getAsInt(final CSVRecord row, final String header) {
        try {
            return Integer.valueOf(row.get(header));
        } catch (final NumberFormatException e) {
            return null;
        }
    }

    private void validateKeyValues(final List<CsvValidationFailure> validationFailures,
                                                         final String school,
                                                         final String group,
                                                         final Integer schoolYear,
                                                         final long recordNumber) {
        if (isBlank(school)) {
            validationFailures.add(CsvValidationFailure.builder()
                    .row(recordNumber)
                    .message("Record does not contain a school")
                    .build());
        }

        if (isBlank(group)) {
            validationFailures.add(CsvValidationFailure.builder()
                    .row(recordNumber)
                    .message("Record does not contain a group name")
                    .build());
        }

        if (schoolYear == null) {
            validationFailures.add(CsvValidationFailure.builder()
                    .row(recordNumber)
                    .message("Record does not contain a school year")
                    .build());
        }
    }

    private void validateSchool(final List<CsvValidationFailure> validationFailures,
                                                      final Set<String> availableSchools,
                                                      final Set<String> completedSchools,
                                                      final String school,
                                                      final long recordNumber) {
        if (!availableSchools.contains(school)) {
            validationFailures.add(CsvValidationFailure.builder()
                    .row(recordNumber)
                    .message("School [" + school + "] can not be found")
                    .build());
        }
        if (completedSchools.contains(school)) {
            validationFailures.add(CsvValidationFailure.builder()
                    .row(recordNumber)
                    .message("School [" + school + "] is out-of-order: sort CSV by school, group, year")
                    .build());
        }
    }

}
