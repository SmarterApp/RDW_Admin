package org.opentestsystem.rdw.admin.service.impl;

import com.google.common.base.Charsets;
import com.google.common.io.Closer;
import org.apache.commons.codec.binary.Hex;
import org.apache.commons.codec.digest.DigestUtils;
import org.apache.commons.csv.CSVFormat;
import org.apache.commons.csv.CSVParser;
import org.apache.commons.csv.CSVPrinter;
import org.apache.commons.csv.CSVRecord;
import org.opentestsystem.rdw.admin.model.CsvValidationFailure;
import org.opentestsystem.rdw.admin.model.ImportStatus;
import org.opentestsystem.rdw.admin.model.StudentGroupBatch;
import org.opentestsystem.rdw.admin.repository.StudentGroupBatchRepository;
import org.opentestsystem.rdw.admin.security.User;
import org.opentestsystem.rdw.admin.service.CsvValidationService;
import org.opentestsystem.rdw.admin.service.StudentGroupBatchService;
import org.opentestsystem.rdw.archive.ArchiveService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.web.multipart.MultipartFile;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.Reader;
import java.nio.file.Files;
import java.security.DigestInputStream;
import java.security.MessageDigest;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import static org.apache.commons.lang.StringUtils.isBlank;
import static org.opentestsystem.rdw.admin.service.CsvValidationService.HeaderSchool;

@Service
class DefaultStudentGroupBatchService implements StudentGroupBatchService {
    private static final Logger logger = LoggerFactory.getLogger(DefaultStudentGroupBatchService.class);

    private final StudentGroupBatchRepository repository;
    private final ArchiveService archiveService;
    private final CsvValidationService validationService;

    @Autowired
    public DefaultStudentGroupBatchService(final StudentGroupBatchRepository repository,
                                           final ArchiveService archiveService,
                                           final CsvValidationService validationService) {
        this.repository = repository;
        this.archiveService = archiveService;
        this.validationService = validationService;
    }

    @Override
    public Iterable<StudentGroupBatch> findAllStudentGroupBatches(final User user) {
        return repository.findByCreator(user.getUsername());
    }

    @Override
    public StudentGroupBatch upload(final User user, final MultipartFile file) {

        final StudentGroupBatch.Builder studentGroupBatchBuilder = StudentGroupBatch.builder().creator(user.getUsername());

        final MessageDigest messageDigest = DigestUtils.getMd5Digest();
        final List<CsvValidationFailure> validationFailures = new ArrayList<>();
        try {
            try (final DigestInputStream digestStream = new DigestInputStream(file.getInputStream(), messageDigest)) {
                validationFailures.addAll(validate(digestStream, user));
            }

            final String digest = Hex.encodeHexString(messageDigest.digest()).toUpperCase();
            final ImportStatus status = validationFailures.isEmpty() ? ImportStatus.ACCEPTED : ImportStatus.BAD_DATA;
            studentGroupBatchBuilder
                    .digest(digest)
                    .message(validationService.toMessage(validationFailures))
                    .status(status);


//            try (final InputStream fileStream = file.getInputStream()) {
//                final Properties properties = new Properties();
//                properties.put(Headers.CONTENT_TYPE, file.getContentType());
//                properties.put(Headers.CONTENT_LENGTH, file.getSize());
//                properties.setProperty("username", user.getUsername());
//                properties.setProperty("filename", file.getName());
//
//                //TODO: check if the digest already exists
//
//                final String location = new LocationStrategy.GroupUploadContentLocationStrategy().location(digest);
//                archiveService.writeResource(location, fileStream, properties);
//
//                studentGroupBatchBuilder
//                        .digest(digest)
//                        .status(ImportStatus.ACCEPTED);

        } catch (final Exception ex) {
            studentGroupBatchBuilder
                    .digest(Hex.encodeHexString(messageDigest.digest()).toUpperCase())
                    .message(ex.getMessage())
                    .status(ImportStatus.BAD_DATA);
        }
        return repository.create(studentGroupBatchBuilder.build());
    }

    /**
     * Chunk the uploaded payload by school id. Perform basic validation.
     *
     * @param inputStream       The uploaded payload
     * @param permissionScope   The user permissions
     * @return Any validation failures
     */
    private List<CsvValidationFailure> validate(final InputStream inputStream, final User user) {
        final List<CsvValidationFailure> validationFailures = new ArrayList<>();

        try (final Reader reader = new InputStreamReader(inputStream, Charsets.UTF_8)) {
            final CSVParser parser = CSVFormat.RFC4180
                    .withFirstRecordAsHeader()
                    .withIgnoreHeaderCase()
                    .parse(reader);

            final Iterator<CSVRecord> recordIterator = parser.iterator();
            if (!recordIterator.hasNext()) {
                validationFailures.add(CsvValidationFailure.builder()
                        .row(0)
                        .message("Empty file")
                        .build());
                return validationFailures;
            }

            validationFailures.addAll(validationService.validateHeaders(parser.getHeaderMap().keySet()));

            validationFailures.addAll(validationService.validateRecords(recordIterator, user));

        } catch (final IOException ex) {
            validationFailures.add(CsvValidationFailure.builder()
                    .row(0)
                    .message("Error reading file [" + ex.getMessage() + "]")
                    .build());
        }

        return validationFailures;
    }

    private void writeRow(final CSVRecord row, final ChunkResult chunkResult) {
        final String schoolId = row.get(HeaderSchool);
        if (isBlank(schoolId)) {
            chunkResult.getFailures().add(CsvValidationFailure.builder()
                    .row(row.getRecordNumber())
                    .message("No " + HeaderSchool + " value for row")
                    .build());
            return;
        }

//        final CSVPrinter printer = chunkResult.getPrinterForChunk(schoolId);
//        printer.printRecord(row);
    }

    private static class ChunkResult {
        private final Closer closer = Closer.create();
        private final Map<String, File> chunkFiles = new HashMap<>();
        private final Map<String, CSVPrinter> chunkPrinters = new HashMap<>();
        private final List<CsvValidationFailure> validationFailures = new ArrayList<>();
        private final CSVFormat format = CSVFormat.RFC4180
                .withFirstRecordAsHeader()
                .withIgnoreHeaderCase();

        public Collection<String> getChunks() {
            return chunkFiles.keySet();
        }

        public File getChunkFile(final String chunk) {
            return chunkFiles.computeIfAbsent(chunk, id -> {
                try {
                    return Files.createTempFile("chunk", ".csv").toFile();
                } catch (final IOException e) {
                    logger.warn("Unable to create temporary chunk csv", e);
                    throw new RuntimeException(e);
                }
            });
        }

//        public CSVPrinter getPrinterForChunk(final String chunk) {
//            return chunkPrinters.computeIfAbsent(chunk, id -> {
//                try {
//                    final CSVFormat chunkFormat = format.withHeader()
//                    return closer.register(new CSVPrinter(new FileWriter(getChunkFile(chunk)), format));
//                } catch (final IOException e) {
//                    logger.warn("Unable to open temporary chunk csv for writing", e);
//                    throw new RuntimeException(e);
//                }
//            });
//        }

        public List<CsvValidationFailure> getFailures() {
            return validationFailures;
        }

        public Closer getCloser() {
            return closer;
        }
    }
}
