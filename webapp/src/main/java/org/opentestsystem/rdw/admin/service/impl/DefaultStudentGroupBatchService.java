package org.opentestsystem.rdw.admin.service.impl;

import com.amazonaws.services.s3.Headers;
import com.google.common.base.Charsets;
import com.google.common.collect.Ordering;
import org.apache.commons.codec.binary.Hex;
import org.apache.commons.codec.digest.DigestUtils;
import org.apache.commons.csv.CSVFormat;
import org.apache.commons.csv.CSVParser;
import org.apache.commons.csv.CSVRecord;
import org.opentestsystem.rdw.admin.common.security.PermissionScope;
import org.opentestsystem.rdw.admin.model.CsvValidationFailure;
import org.opentestsystem.rdw.admin.model.GroupMessage;
import org.opentestsystem.rdw.admin.model.ImportStatus;
import org.opentestsystem.rdw.admin.model.StudentGroupBatch;
import org.opentestsystem.rdw.admin.repository.StudentGroupBatchRepository;
import org.opentestsystem.rdw.admin.security.User;
import org.opentestsystem.rdw.admin.service.CsvValidationService;
import org.opentestsystem.rdw.admin.service.GroupsSource;
import org.opentestsystem.rdw.admin.service.LocationStrategy;
import org.opentestsystem.rdw.admin.service.StudentGroupBatchService;
import org.opentestsystem.rdw.archive.ArchiveService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cloud.stream.annotation.EnableBinding;
import org.springframework.cloud.stream.messaging.Source;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.multipart.MultipartFile;

import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.Reader;
import java.security.DigestInputStream;
import java.security.MessageDigest;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Properties;

import static com.google.common.collect.Lists.newArrayList;
import static com.google.common.collect.Maps.newHashMap;
import static org.apache.commons.lang.StringEscapeUtils.escapeJava;

@Service
@EnableBinding(Source.class)
class DefaultStudentGroupBatchService implements StudentGroupBatchService {
    private static final Logger logger = LoggerFactory.getLogger(DefaultStudentGroupBatchService.class);

    private final StudentGroupBatchRepository repository;
    private final ArchiveService archiveService;
    private final CsvValidationService validationService;
    private final GroupsSource source;

    @Autowired
    public DefaultStudentGroupBatchService(final StudentGroupBatchRepository repository,
                                           final ArchiveService archiveService,
                                           final CsvValidationService validationService,
                                           final GroupsSource source) {
        this.repository = repository;
        this.archiveService = archiveService;
        this.validationService = validationService;
        this.source = source;
    }

    @Override
    public Iterable<StudentGroupBatch> findAllStudentGroupBatches(final User user) {
        return repository.findByCreator(user.getUsername());
    }

    @Override
    public StudentGroupBatch upload(final User user, final MultipartFile file) {
        logger.debug("Processing upload request: {}", file.getOriginalFilename());

        final PermissionScope permissionScope = user
                .getPermissionsById()
                .get("GROUP_WRITE")
                .getScope();

        final StudentGroupBatch.Builder studentGroupBatchBuilder = StudentGroupBatch.builder()
                .creator(user.getUsername())
                .filename(file.getOriginalFilename());

        final MessageDigest messageDigest = DigestUtils.getMd5Digest();

        try {
            final List<CsvValidationFailure> validationFailures = newArrayList();
            final Map<String, String> fileProperties = newHashMap();
            fileProperties.put("username", user.getUsername());

            try (final DigestInputStream digestStream = new DigestInputStream(file.getInputStream(), messageDigest)) {
                validate(digestStream, permissionScope, validationFailures, fileProperties);
            }

            final String digest = Hex.encodeHexString(messageDigest.digest()).toUpperCase();
            if (validationFailures.isEmpty()) {
                logger.debug("Validated request: {}", file.getOriginalFilename());
                archiveFile(file, digest, fileProperties);
                studentGroupBatchBuilder
                        .digest(digest)
                        .status(ImportStatus.ACCEPTED);
            } else {
                logger.info("Request failed validation: {}", file.getOriginalFilename());
                archiveFile(file, digest, fileProperties);
                studentGroupBatchBuilder
                        .digest(digest)
                        .message(validationService.toMessage(validationFailures))
                        .status(ImportStatus.BAD_DATA);
            }
        } catch (final Exception ex) {
            logger.warn("Upload request failed with exception: {}", file.getOriginalFilename(), ex);
            studentGroupBatchBuilder
                    .digest(Hex.encodeHexString(messageDigest.digest()).toUpperCase())
                    .message("Exception processing upload: " + ex.getMessage())
                    .status(ImportStatus.BAD_DATA);
        }

        final StudentGroupBatch sgbImport = repository.create(studentGroupBatchBuilder.build());
        if (sgbImport.getStatus().equals(ImportStatus.ACCEPTED)) {
            source.send(
                    new GroupMessage.Builder()
                            .digest(sgbImport.getDigest())
                            .uploadId(sgbImport.getId())
                            .build().toJson().getBytes(Charsets.UTF_8),
                    MediaType.APPLICATION_JSON.toString(),
                    sgbImport.getId()
            );
        }

        return sgbImport;
    }

    private void archiveFile(final MultipartFile file,
                             final String digest,
                             final Map<String, String> fileProperties) throws IOException {
        try (final InputStream fileStream = file.getInputStream()) {
            final String location = new LocationStrategy.GroupUploadContentLocationStrategy().location(digest);

            //Check if file already exists in ArchiveService
            if (archiveService.exists(location)) {
                logger.debug("Upload already exists in S3: {}", file.getOriginalFilename());
                return;
            }

            final Properties properties = new Properties();
            properties.putAll(fileProperties);
            properties.put(Headers.CONTENT_TYPE, file.getContentType());
            properties.put(Headers.CONTENT_LENGTH, file.getSize());
            properties.setProperty("filename", file.getOriginalFilename());

            archiveService.writeResource(location, fileStream, properties);

            logger.debug("Uploaded request: {}", file.getOriginalFilename());
        }
    }

    /**
     * Chunk the uploaded payload by school id. Perform basic validation.
     *
     * @param inputStream        The uploaded payload
     * @param permissionScope    The user permissions
     * @param validationFailures Collection of validation failures; this method adds to it
     */
    private void validate(final InputStream inputStream,
                          final PermissionScope permissionScope,
                          final Collection<CsvValidationFailure> validationFailures,
                          final Map<String, String> fileProperties) throws IOException {
        try (final Reader reader = new InputStreamReader(inputStream, Charsets.UTF_8)) {
            final CSVParser parser = CSVFormat.DEFAULT
                    .withFirstRecordAsHeader()
                    .withIgnoreHeaderCase()
                    .parse(reader);

            final Iterator<CSVRecord> recordIterator = parser.iterator();
            if (!recordIterator.hasNext()) {
                validationFailures.add(CsvValidationFailure.builder()
                        .row(0)
                        .message("Empty file")
                        .build());
                return;
            }

            // enhance file properties with the newline sequence and field delimiter (hard-coded for now)
            // note that the sequences are escaped, e.g. "\\r\\n"
            fileProperties.put("newline", escapeJava(parser.getFirstEndOfLine()));
            fileProperties.put("delimiter", escapeJava(","));

            final List<String> orderedHeaders = newArrayList(parser.getHeaderMap().keySet());
            final Ordering<String> ordering = Ordering.natural().onResultOf(header -> parser.getHeaderMap().get(header));
            orderedHeaders.sort(ordering);
            validationFailures.addAll(validationService.validateHeaders(orderedHeaders));
            validationFailures.addAll(validationService.validateRecords(recordIterator, permissionScope));

        } catch (final IOException ex) {
            logger.warn("Problem reading uploaded file", ex);
            validationFailures.add(CsvValidationFailure.builder()
                    .row(0)
                    .message("Error reading file [" + ex.getMessage() + "]")
                    .build());
        } catch (final IllegalArgumentException ex) {
            logger.warn("Problem parsing uploaded file", ex);
            validationFailures.clear();
            validationFailures.add(CsvValidationFailure.builder()
                    .row(0)
                    .message("File does not appear to be a valid CSV with a header row")
                    .build());
        }
    }

}
