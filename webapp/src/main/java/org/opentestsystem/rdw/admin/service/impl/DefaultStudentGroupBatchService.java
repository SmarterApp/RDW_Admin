package org.opentestsystem.rdw.admin.service.impl;

import com.amazonaws.services.s3.Headers;
import com.fasterxml.jackson.core.JsonParser;
import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonObjectFormatVisitor;
import org.apache.commons.codec.binary.Hex;
import org.apache.commons.codec.digest.DigestUtils;
import org.apache.commons.csv.CSVFormat;
import org.apache.commons.csv.CSVRecord;
import org.opentestsystem.rdw.admin.model.ImportStatus;
import org.opentestsystem.rdw.admin.model.StudentGroupBatch;
import org.opentestsystem.rdw.admin.repository.StudentGroupBatchRepository;
import org.opentestsystem.rdw.admin.security.User;
import org.opentestsystem.rdw.admin.service.GroupsSource;
import org.opentestsystem.rdw.admin.service.LocationStrategy;
import org.opentestsystem.rdw.admin.service.StudentGroupBatchService;
import org.opentestsystem.rdw.archive.ArchiveService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cloud.stream.annotation.EnableBinding;
import org.springframework.cloud.stream.messaging.Source;
import org.springframework.http.MediaType;
import org.springframework.integration.support.MessageBuilder;
import org.springframework.stereotype.Service;
import org.springframework.web.multipart.MultipartFile;

import javax.validation.constraints.NotNull;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.Reader;
import java.nio.charset.Charset;
import java.security.DigestInputStream;
import java.security.MessageDigest;
import java.util.Iterator;
import java.util.Properties;
import java.util.Set;
import java.util.stream.Collectors;

import static com.google.common.collect.Lists.newArrayList;

@Service
@EnableBinding(Source.class)
class DefaultStudentGroupBatchService implements StudentGroupBatchService {

    private static final Logger logger = LoggerFactory.getLogger(DefaultStudentGroupBatchService.class);
    private final StudentGroupBatchRepository repository;
    private final ArchiveService archiveService;
    private final GroupsSource source;

    @Autowired
    public DefaultStudentGroupBatchService(@NotNull final StudentGroupBatchRepository repository,
                                           final ArchiveService archiveService,
                                           final GroupsSource source) {
        this.repository = repository;
        this.archiveService = archiveService;
        this.source = source;
    }

    @Override
    public Iterable<StudentGroupBatch> findAllStudentGroupBatches(final User user) {
        return repository.findByCreator(user.getUsername());
    }

    @Override
    public StudentGroupBatch upload(final User user, final MultipartFile file) {

        final StudentGroupBatch.Builder studentGroupBatchBuilder = StudentGroupBatch.builder().creator(user.getUsername());
        StudentGroupBatch sgbImport;

        final MessageDigest messageDigest = DigestUtils.getMd5Digest();
        try (final DigestInputStream digestStream = new DigestInputStream(file.getInputStream(), messageDigest)) {
            validate(digestStream);
        } catch (final Exception ex) {
            studentGroupBatchBuilder
                    .digest("") //TODO: should digest be optional?
                    .message(ex.getMessage())
                    .status(ImportStatus.BAD_DATA);
            return repository.create(studentGroupBatchBuilder.build());
        }

        final String digest = Hex.encodeHexString(messageDigest.digest()).toUpperCase();
        try (final InputStream fileStream = file.getInputStream()) {
            final Properties properties = new Properties();
            properties.put(Headers.CONTENT_TYPE, file.getContentType());
            properties.put(Headers.CONTENT_LENGTH, file.getSize());
            properties.setProperty("username", user.getUsername());
            properties.setProperty("filename", file.getName());

            //TODO: check if the digest already exists
            sgbImport = repository.findOneByDigest(digest);
            if (sgbImport != null) {
                logger.info("Ignoring file name {} with existing digest {}", file.getName(), digest);
            }

            final String location = new LocationStrategy.GroupUploadContentLocationStrategy().location(digest);
            archiveService.writeResource(location, fileStream, properties);

            studentGroupBatchBuilder
                    .digest(digest)
                    .status(ImportStatus.ACCEPTED);

            sgbImport = repository.create(studentGroupBatchBuilder.build());

            //Yes, I know. This is just temporary.
            source.send("{\"data\":\"this is data for now\"}".getBytes("UTF-8"), digest,
                    MediaType.APPLICATION_JSON.toString(), sgbImport.getId());

            return sgbImport;

        } catch (final Exception ex) {
            studentGroupBatchBuilder
                    .digest("") //TODO: should digest be optional?
                    .message(ex.getMessage())
                    .status(ImportStatus.BAD_DATA);
            sgbImport = repository.create(studentGroupBatchBuilder.build());
        }
        return sgbImport;
    }

    // TODO: add more validation ?
    private void validate(final InputStream inputStream) {
        try (final Reader reader = new InputStreamReader(inputStream, Charset.forName("utf8"))) {
            final Iterator<CSVRecord> recordIterator = CSVFormat.RFC4180.withFirstRecordAsHeader().parse(reader).iterator();
            if (!recordIterator.hasNext()) throw new IllegalArgumentException("Empty file");

            final Set<String> headers = recordIterator.next().toMap().keySet().stream().map(v -> v.toLowerCase()).collect(Collectors.toSet());
            if (!headers.containsAll(newArrayList("school_natural_id", "subject_code", "group_name", "group_user_login", "school_year", "student_ssid"))) {
                throw new IllegalArgumentException("Missing headers, found " + headers);
            }
        } catch (final IOException ex) {
            throw new IllegalArgumentException("Error reading file [" + ex.getMessage() + "]");
        }
    }
}
