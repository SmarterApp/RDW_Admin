package org.opentestsystem.rdw.admin.service.impl;

import org.apache.commons.codec.digest.DigestUtils;
import org.apache.commons.csv.CSVFormat;
import org.apache.commons.csv.CSVRecord;
import org.opentestsystem.rdw.admin.model.ImportStatus;
import org.opentestsystem.rdw.admin.model.StudentGroupBatch;
import org.opentestsystem.rdw.admin.repository.StudentGroupBatchRepository;
import org.opentestsystem.rdw.admin.security.User;
import org.opentestsystem.rdw.admin.service.GroupsSource;
import org.opentestsystem.rdw.admin.service.LocationStrategy;
import org.opentestsystem.rdw.admin.service.StudentGroupBatchService;
import org.opentestsystem.rdw.archive.ArchiveService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cloud.stream.annotation.EnableBinding;
import org.springframework.cloud.stream.messaging.Source;
import org.springframework.integration.support.MessageBuilder;
import org.springframework.stereotype.Service;
import org.springframework.web.multipart.MultipartFile;

import javax.validation.constraints.NotNull;
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.Reader;
import java.nio.charset.Charset;
import java.util.Iterator;
import java.util.Properties;
import java.util.Set;
import java.util.stream.Collectors;

import static com.google.common.collect.Lists.newArrayList;

@Service
@EnableBinding(Source.class)
class DefaultStudentGroupBatchService implements StudentGroupBatchService {

    private static final Logger logger = LoggerFactory.getLogger(DefaultStudentGroupBatchService.class);
    private final StudentGroupBatchRepository repository;
    private final ArchiveService archiveService;
    private final GroupsSource source;

    @Autowired
    public DefaultStudentGroupBatchService(@NotNull final StudentGroupBatchRepository repository,
                                           final ArchiveService archiveService,
                                           final GroupsSource source) {
        this.repository = repository;
        this.archiveService = archiveService;
        this.source = source;
    }

    @Override
    public Iterable<StudentGroupBatch> findAllStudentGroupBatches(final User user) {
        return repository.findByCreator(user.getUsername());
    }

    @Override
    public StudentGroupBatch upload(final User user, final MultipartFile file) {

        final StudentGroupBatch.Builder studentGroupBatchBuilder = StudentGroupBatch.builder().creator(user.getUsername());
        StudentGroupBatch sgbImport;

        try {
            final String digest = DigestUtils.md5Hex(validate(file.getBytes())).toUpperCase();
            final Properties properties = new Properties();
            properties.setProperty("content-type", file.getContentType());
            properties.setProperty("username", user.getUsername());
            properties.setProperty("size", Long.toString(file.getSize()));
            properties.setProperty("filename", file.getName());

            //TODO: check if the digest already exists
            sgbImport = repository.findOneByDigest(digest);
            if (sgbImport != null) {
                logger.info("Ignoring file name {} with existing digest {}", file.getName(), digest);
            }

            final String location = new LocationStrategy.GroupUploadContentLocationStrategy().location(digest);
            archiveService.writeResource(location, file.getInputStream(), properties);

            studentGroupBatchBuilder
                    .digest(digest)
                    .status(ImportStatus.ACCEPTED);

            sgbImport = repository.create(studentGroupBatchBuilder.build());
            source.send(digest, sgbImport.getId());
            return sgbImport;

        } catch (final Exception ex) {
            studentGroupBatchBuilder
                    .digest("") //TODO: should digest be optional?
                    .message(ex.getMessage())
                    .status(ImportStatus.BAD_DATA);
            sgbImport = repository.create(studentGroupBatchBuilder.build());
        }
        return sgbImport;
    }

    // TODO: add more validation ?
    private byte[] validate(final byte[] input) {
        try (final Reader reader = new InputStreamReader(new ByteArrayInputStream(input), Charset.forName("utf8"))) {
            final Iterator<CSVRecord> recordIterator = CSVFormat.RFC4180.withFirstRecordAsHeader().parse(reader).iterator();
            if (!recordIterator.hasNext()) throw new IllegalArgumentException("Empty file");

            final Set<String> headers = recordIterator.next().toMap().keySet().stream().map(v -> v.toLowerCase()).collect(Collectors.toSet());
            if (!headers.containsAll(newArrayList("school_natural_id", "subject_code", "group_name", "group_user_login", "school_year", "student_ssid"))) {
                throw new IllegalArgumentException("Missing headers, found " + headers);
            }

            return input;
        } catch (final IOException ex) {
            throw new IllegalArgumentException("Error reading file [" + ex.getMessage() + "]");
        }
    }
}
