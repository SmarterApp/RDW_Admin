package org.opentestsystem.rdw.admin.service.impl;

import org.apache.commons.codec.digest.DigestUtils;
import org.apache.commons.csv.CSVFormat;
import org.apache.commons.csv.CSVRecord;
import org.opentestsystem.rdw.admin.model.ImportStatus;
import org.opentestsystem.rdw.admin.model.StudentGroupBatch;
import org.opentestsystem.rdw.admin.repository.StudentGroupBatchRepository;
import org.opentestsystem.rdw.admin.security.User;
import org.opentestsystem.rdw.admin.service.LocationStrategy;
import org.opentestsystem.rdw.admin.service.StudentGroupBatchService;
import org.opentestsystem.rdw.archive.ArchiveService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.web.multipart.MultipartFile;

import javax.validation.constraints.NotNull;
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.Reader;
import java.nio.charset.Charset;
import java.util.Iterator;
import java.util.Properties;
import java.util.Set;

import static com.google.common.collect.Lists.newArrayList;

@Service
class DefaultStudentGroupBatchService implements StudentGroupBatchService {

    private final StudentGroupBatchRepository repository;
    private final ArchiveService archiveService;

    @Autowired
    public DefaultStudentGroupBatchService(@NotNull final StudentGroupBatchRepository repository,
                                           final ArchiveService archiveService) {
        this.repository = repository;
        this.archiveService = archiveService;
    }

    @Override
    public Iterable<StudentGroupBatch> findAllStudentGroupBatches(final User user) {
        return repository.findByCreator(user.getUsername());
    }

    @Override
    public StudentGroupBatch upload(final User user, final MultipartFile file) {

        final StudentGroupBatch.Builder studentGroupBatchBuilder = StudentGroupBatch.builder().creator(user.getUsername());

        try {
            final String digest = DigestUtils.md5Hex(validate(file.getBytes())).toUpperCase();
            final Properties properties = new Properties();
            properties.setProperty("content-type", file.getContentType());
            properties.setProperty("username", user.getUsername());
            properties.setProperty("size", Long.toString(file.getSize()));

            //TODO: check if the digest already exists

            final String location = new LocationStrategy.GroupUploadContentLocationStrategy().location(digest);
            archiveService.writeResource(location, file.getInputStream(), properties);

            studentGroupBatchBuilder
                    .digest(digest)
                    .status(ImportStatus.ACCEPTED);

        } catch (final Exception ex) {
            studentGroupBatchBuilder
                    .digest("") //TODO: should digest be optional?
                    .message(ex.getMessage())
                    .status(ImportStatus.BAD_DATA);
        }
        return repository.create(studentGroupBatchBuilder.build());

    }

    private byte[] validate(final byte[] input) {
        try (final Reader reader = new InputStreamReader(new ByteArrayInputStream(input), Charset.forName("utf8"))) {
            final Iterator<CSVRecord> recordIterator = CSVFormat.RFC4180.withFirstRecordAsHeader().parse(reader).iterator();
            if (!recordIterator.hasNext()) throw new IllegalArgumentException("Empty file");

            final Set<String> headers = recordIterator.next().toMap().keySet();
            if (!headers.containsAll(newArrayList("school_natural_id", "subject_code", "group_name", "group_user_login", "school_year", "student_ssid"))) {
                throw new IllegalArgumentException("Missing headers, found [" + headers + "]");
            }

            return input;
        } catch (final IOException ex) {
            throw new IllegalArgumentException("Error reading file [" + ex.getMessage() + "]");
        }
    }
}
