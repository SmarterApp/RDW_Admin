package org.opentestsystem.rdw.admin.service.impl;

import com.google.common.base.Joiner;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableSet;
import org.apache.commons.codec.digest.DigestUtils;
import org.junit.Before;
import org.junit.Test;
import org.opentestsystem.rdw.admin.model.ImportStatus;
import org.opentestsystem.rdw.admin.model.StudentGroupBatch;
import org.opentestsystem.rdw.admin.repository.StudentGroupBatchRepository;
import org.opentestsystem.rdw.admin.security.User;
import org.opentestsystem.rdw.admin.service.GroupsSource;
import org.opentestsystem.rdw.archive.ArchiveService;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.web.multipart.MultipartFile;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.util.List;
import java.util.stream.Collectors;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Matchers.any;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;

public class DefaultStudentGroupBatchServiceTest {
    private static final Joiner CommaJoiner = Joiner.on(",");
    private static final Joiner LineJoiner = Joiner.on("\n");

    private static final List<String> ValidHeaders = ImmutableList.of(
            "school_natural_id",
            "subject_code",
            "group_name",
            "group_user_login",
            "school_year",
            "student_ssid"
    );

    private static final List<String> ValidValues = ImmutableList.copyOf(ValidHeaders.stream()
            .map(header -> header + "_val")
            .collect(Collectors.toList()));

    private StudentGroupBatchRepository repository;
    private ArchiveService archiveService;
    private DefaultStudentGroupBatchService service;
    private MultipartFile file;
    private GroupsSource source;

    private User user = User.builder()
            .id("user")
            .username("test")
            .authorities(ImmutableSet.of(new SimpleGrantedAuthority("ROLE_USER")))
            .build();

    @Before
    public void before() {
        repository = mock(StudentGroupBatchRepository.class);
        archiveService = mock(ArchiveService.class);
        source = mock(GroupsSource.class);
        service = new DefaultStudentGroupBatchService(repository, archiveService, source);

        file = mock(MultipartFile.class);
        when(file.getName()).thenReturn("file name");
        when(file.getSize()).thenReturn(150L);
        when(file.getContentType()).thenReturn("csv");
        when(repository.create(any(StudentGroupBatch.class))).thenAnswer(invocation -> invocation.getArguments()[0]);
    }

    @Test
    public void itShouldUseRepositoryToFindAllStudentGroupBatches() throws IOException {
        final Iterable studentGroupBatches = mock(Iterable.class);
        when(repository.findByCreator("test")).thenReturn(studentGroupBatches);

        assertThat(service.findAllStudentGroupBatches(user)).isEqualTo(studentGroupBatches);
    }

    @Test
    public void itShouldUpload() throws IOException {
        final String payload = payload(ValidHeaders, ValidValues);
        when(file.getInputStream()).thenReturn(new ByteArrayInputStream(payload.getBytes()));
        final StudentGroupBatch batch = StudentGroupBatch.builder()
                .creator(user.getUsername())
                .status(ImportStatus.ACCEPTED)
                .digest(DigestUtils.md5Hex(payload.getBytes())
                        .toUpperCase())
                .build();
        assertThat(service.upload(user, file)).isEqualTo(batch);
    }

    @Test
    public void itShouldNotUploadIfColumnHeadersAreMissing() throws IOException {
        final String payload = payload(
                ValidHeaders.subList(0, ValidHeaders.size()-1),
                ValidValues.subList(0, ValidValues.size()-1));

        when(file.getInputStream()).thenReturn(new ByteArrayInputStream(payload.getBytes()));

        final StudentGroupBatch batch = StudentGroupBatch.builder()
                .creator(user.getUsername())
                .status(ImportStatus.BAD_DATA)
                .digest("")
                .message("Missing headers, found [subject_code, group_user_login, group_name, school_natural_id, school_year]")
                .build();
        assertThat(service.upload(user, file)).isEqualTo(batch);
    }

    @Test
    public void itShouldNotUploadEmptyFile() throws IOException {
        when(file.getInputStream()).thenReturn(new ByteArrayInputStream("".getBytes()));

        final StudentGroupBatch batch = StudentGroupBatch.builder()
                .creator(user.getUsername())
                .status(ImportStatus.BAD_DATA)
                .digest("")
                .message("Empty file")
                .build();
        assertThat(service.upload(user, file)).isEqualTo(batch);
    }

    @Test
    public void itShouldNotUploadIfFailedToReadTheFile() throws IOException {
        when(file.getInputStream()).thenThrow(new RuntimeException("failed"));

        final StudentGroupBatch batch = StudentGroupBatch.builder()
                .creator(user.getUsername())
                .status(ImportStatus.BAD_DATA)
                .digest("")
                .message("failed")
                .build();
        assertThat(service.upload(user, file)).isEqualTo(batch);
    }

    private String payload(final List<String> headers, final List<String> values) {
        return LineJoiner.join(CommaJoiner.join(headers), CommaJoiner.join(values));
    }
}