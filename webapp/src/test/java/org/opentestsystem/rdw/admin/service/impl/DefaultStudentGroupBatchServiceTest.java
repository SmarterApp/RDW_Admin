package org.opentestsystem.rdw.admin.service.impl;

import com.google.common.base.Joiner;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import org.apache.commons.codec.binary.Hex;
import org.apache.commons.codec.digest.DigestUtils;
import org.apache.commons.csv.CSVRecord;
import org.junit.Before;
import org.junit.Test;
import org.mockito.ArgumentCaptor;
import org.opentestsystem.rdw.admin.common.security.PermissionScope;
import org.opentestsystem.rdw.admin.model.CsvValidationFailure;
import org.opentestsystem.rdw.admin.model.ImportStatus;
import org.opentestsystem.rdw.admin.model.StudentGroupBatch;
import org.opentestsystem.rdw.admin.repository.StudentGroupBatchRepository;
import org.opentestsystem.rdw.admin.security.Permission;
import org.opentestsystem.rdw.admin.security.User;
import org.opentestsystem.rdw.admin.service.CsvValidationService;
import org.opentestsystem.rdw.admin.service.GroupsSource;
import org.opentestsystem.rdw.archive.ArchiveService;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.web.multipart.MultipartFile;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.Iterator;
import java.util.List;
import java.util.Properties;
import java.util.stream.Collectors;

import static java.util.Collections.emptyList;
import static java.util.Collections.singletonList;
import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Matchers.any;
import static org.mockito.Matchers.anyListOf;
import static org.mockito.Matchers.anyString;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;
import static org.opentestsystem.rdw.admin.model.ImportStatus.ACCEPTED;
import static org.opentestsystem.rdw.admin.model.ImportStatus.BAD_DATA;

public class DefaultStudentGroupBatchServiceTest {
    private static final Joiner CommaJoiner = Joiner.on(",");
    private static final Joiner LineJoiner = Joiner.on("\n");

    private static final List<String> ValidHeaders = ImmutableList.of("header_a", "header_b");

    private static final List<String> ValidValues = ImmutableList.copyOf(ValidHeaders.stream()
            .map(header -> header + "_val")
            .collect(Collectors.toList()));

    private StudentGroupBatchRepository repository;
    private ArchiveService archiveService;
    private DefaultStudentGroupBatchService service;
    private MultipartFile file;
    private CsvValidationService validationService;
    private GroupsSource source;

    private Permission groupWrite = new Permission("GROUP_WRITE", PermissionScope.STATEWIDE);
    private User user = User.builder()
            .id("user")
            .username("test")
            .password("password")
            .authorities(ImmutableSet.of(new SimpleGrantedAuthority("ROLE_USER")))
            .permissionsById(ImmutableMap.of("GROUP_WRITE", groupWrite))
            .build();

    @Before
    public void before() {
        repository = mock(StudentGroupBatchRepository.class);
        archiveService = mock(ArchiveService.class);
        source = mock(GroupsSource.class);
        validationService = mock(CsvValidationService.class);
        when(validationService.toMessage(anyListOf(CsvValidationFailure.class))).thenReturn("message");
        when(validationService.validateHeaders(anyListOf(String.class))).thenAnswer(invocation -> {
            final List<String> headers = invocation.getArgumentAt(0, List.class);
            return ValidHeaders.equals(headers) ? emptyList() : singletonList("Invalid Headers.");
        });
        when(validationService.validateRecords(any(Iterator.class), any(PermissionScope.class)))
                .thenAnswer(invocation -> {
                    final Iterator<CSVRecord> recordIterator = (Iterator<CSVRecord>) invocation.getArgumentAt(0, Iterator.class);
                    while (recordIterator.hasNext()) {
                        recordIterator.next();
                    }
                    return emptyList();
                });

        service = new DefaultStudentGroupBatchService(repository, archiveService, validationService, source);

        file = mock(MultipartFile.class);
        when(file.getOriginalFilename()).thenReturn("file name");
        when(file.getSize()).thenReturn(150L);
        when(file.getContentType()).thenReturn("csv");
        when(repository.create(any(StudentGroupBatch.class))).thenAnswer(invocation -> invocation.getArguments()[0]);
    }

    @Test
    public void itShouldUseRepositoryToFindAllStudentGroupBatches() throws IOException {
        final Iterable<StudentGroupBatch> studentGroupBatches = mock(Iterable.class);
        when(repository.findByCreator("test")).thenReturn(studentGroupBatches);

        assertThat(service.findAllStudentGroupBatches(user)).isEqualTo(studentGroupBatches);
    }

    @Test
    public void itShouldUpload() throws IOException {
        final String payload = payload(ValidHeaders, ValidValues);
        when(file.getInputStream()).thenReturn(new ByteArrayInputStream(payload.getBytes()));

        final StudentGroupBatch batch = StudentGroupBatch.builder()
                .creator(user.getUsername())
                .status(ACCEPTED)
                .digest(DigestUtils.md5Hex(payload.getBytes()).toUpperCase())
                .build();
        assertThat(service.upload(user, file)).isEqualTo(batch);
    }

    @Test
    public void itShouldNotUploadIfColumnHeadersAreMissing() throws IOException {
        final String payload = payload(ValidHeaders, ValidValues);
        when(file.getInputStream()).thenReturn(new ByteArrayInputStream(payload.getBytes()));
        when(validationService.validateHeaders(anyListOf(String.class)))
                .thenReturn(singletonList(CsvValidationFailure.builder()
                        .row(0)
                        .message("Bad stuffs")
                        .build()));

        final StudentGroupBatch batch = StudentGroupBatch.builder()
                .creator(user.getUsername())
                .status(BAD_DATA)
                .digest(Hex.encodeHexString(DigestUtils.md5(payload)).toUpperCase())
                .message("message")
                .build();
        assertThat(service.upload(user, file)).isEqualTo(batch);
    }

    @Test
    public void itShouldNotUploadEmptyFile() throws IOException {
        when(file.getInputStream()).thenReturn(new ByteArrayInputStream("".getBytes()));

        final StudentGroupBatch batch = StudentGroupBatch.builder()
                .creator(user.getUsername())
                .status(BAD_DATA)
                .digest(Hex.encodeHexString(DigestUtils.md5("")).toUpperCase())
                .message("message")
                .build();
        assertThat(service.upload(user, file)).isEqualTo(batch);
    }

    @Test
    public void itShouldNotUploadIfFailedToReadTheFile() throws IOException {
        when(file.getInputStream()).thenThrow(new RuntimeException("failed"));

        final StudentGroupBatch batch = StudentGroupBatch.builder()
                .creator(user.getUsername())
                .status(BAD_DATA)
                .digest(Hex.encodeHexString(DigestUtils.md5("")).toUpperCase())
                .message("Exception processing upload: failed")
                .build();
        assertThat(service.upload(user, file)).isEqualTo(batch);
    }

    @Test
    public void itShouldSetNewlineToCR() throws IOException {
        final Properties properties = captureArchiveProperties("/test.cr.csv", ACCEPTED);
        assertThat(properties.getProperty("delimiter")).isEqualTo(",");
        assertThat(properties.getProperty("newline")).isEqualTo("\\r");
    }

    @Test
    public void itShouldSetNewlineToLF() throws IOException {
        final Properties properties = captureArchiveProperties("/test.lf.csv", ACCEPTED);
        assertThat(properties.getProperty("delimiter")).isEqualTo(",");
        assertThat(properties.getProperty("newline")).isEqualTo("\\n");
    }

    @Test
    public void itShouldSetNewlineToCRLF() throws IOException {
        final Properties properties = captureArchiveProperties("/test.crlf.csv", ACCEPTED);
        assertThat(properties.getProperty("delimiter")).isEqualTo(",");
        assertThat(properties.getProperty("newline")).isEqualTo("\\r\\n");
    }

    @Test
    public void delimiterDetectionIsNotImplemented() throws IOException {
        // for now, a tab-delimited file will be treated as a csv with bad data
        final Properties properties = captureArchiveProperties("/test.crlf.tsv", BAD_DATA);
        assertThat(properties.getProperty("delimiter")).isEqualTo(",");
        assertThat(properties.getProperty("newline")).isEqualTo("\\r\\n");
    }

    private Properties captureArchiveProperties(final String resource, final ImportStatus expectedStatus) throws IOException {
        when(file.getInputStream()).thenReturn(this.getClass().getResourceAsStream(resource));
        assertThat(service.upload(user, file).getStatus()).isEqualTo(expectedStatus);
        final ArgumentCaptor<Properties> propertiesCaptor = ArgumentCaptor.forClass(Properties.class);
        verify(archiveService).writeResource(anyString(), any(InputStream.class), propertiesCaptor.capture());
        return propertiesCaptor.getValue();
    }

    private String payload(final List<String> headers, final List<String> values) {
        return LineJoiner.join(CommaJoiner.join(headers), CommaJoiner.join(values));
    }
}